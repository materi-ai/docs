---
title: Deployment Architecture Decisions (ADR)
description: Architecture decision record for deployment strategy, service orchestration,
icon: sitemap
source: /Users/alexarno/materi/DEPLOYMENT_ARCHITECTURE_DECISIONS.md
sourceRepo: "https://github.com/materi-ai/materi"
lastMigrated: "2026-01-09T08:48:35.565829Z"
status: migrated
tags: 
relatedPages:
  - developer/domain/shield/authentication.md
  - developer/domain/shield/database-schema.mdx
  - developer/domain/shield/authorization.md
  - developer/domain/shield/user-management.md
  - developer/domain/shield/oauth-saml.md
---

# Deployment Orchestration: Architecture Decisions

**Purpose**: Document key architectural choices for unified deployment orchestration
**Date**: January 8, 2026
**Status**: Decision Framework (Awaiting Approval)

---

## ADR-001: Use Scribe as Central Orchestrator

### Decision
Extend existing Nestr Scribe CLI tool as the central deployment orchestrator instead of creating a separate tool.

### Rationale
| Factor | Scribe | New Tool | Existing GitHub Actions |
|--------|--------|----------|------------------------|
| **Existing Code** | Yes (CLI framework) | No | Yes |
| **Local Development** | Yes | Maybe | No (GitHub only) |
| **Dry-Run Support** | Easy to add | Medium effort | Complex |
| **Version Control** | Scribe config in repo | Separate tool repo | GitHub Actions only |
| **Team Familiarity** | Go (API team knows) | New language? | GitHub Actions (known) |
| **Cross-Repository Scope** | Perfect (Nestr orchestrates) | Possible | Limited (single repo) |

### Implementation
- Location: `/Users/alexarno/materi/nestr/scribe/cmd/deploy.go`
- Reuse: Scribe's existing CLI framework + config loading
- New: Stage coordination logic + Printery integration

### Risks
- âŒ Scribe CLI may not exist yet (need to verify)
- âŒ Adds complexity to Scribe (mitigated: deploy is isolated subcommand)

### Alternatives Considered
1. **New `materi-orchestrate` CLI**: Too much duplicate infrastructure
2. **Pure GitHub Actions**: Can't run locally or dry-run easily
3. **Terraform**: Overkill for deployment orchestration
4. **Kubernetes Custom Resource Definition**: Too tightly coupled to K8s

### Decision Status: âœ… APPROVED (Architecture maintains consistency)

---

## ADR-002: Parallel Deployment Stages with Explicit Dependencies

### Decision
Deploy Vercel, Railway, and Folio in parallel with explicit dependency checks rather than sequential.

### Rationale
| Benefit | Impact | Implementation |
|---------|--------|-----------------|
| **Speed** | 8-10 min vs 15+ min sequential | Goroutines in Go |
| **Failure Isolation** | Vercel fail â‰  Railway fail | Separate error channels |
| **Observable Progress** | Show 3 bars, not 1 | WebSocket real-time |
| **Dependency Safety** | Can still enforce order | Pre-checks before parallelize |

### Dependency Graph
```
â”Œâ”€ Vercel (Canvas/Office) â”€â”€â”€â”€â”€â”€â”
â”‚                                â”œâ”€ Printery Coordination â”€ Shield Record
â”œâ”€ Railway (5 backends) â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                â”œâ”€ Folio Dashboard Update
â””â”€ Folio (Observability) â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation Strategy
```go
// Scribe orchestration pseudocode:
var vercelErr, railwayErr, folioErr error
var wg sync.WaitGroup

wg.Add(3)

// All 3 start in parallel
go func() {
    defer wg.Done()
    vercelErr = DeployVercel(version)
}()

go func() {
    defer wg.Done()
    railwayErr = DeployRailway(version)
}()

go func() {
    defer wg.Done()
    folioErr = DeployFolio(version)
}()

wg.Wait()

// All 3 complete, then check health
if vercelErr != nil || railwayErr != nil || folioErr != nil {
    // Rollback all 3
    RollbackAll(previousVersion)
} else {
    // Proceed to Printery coordination
    CoordinateServices()
}
```

### Failure Scenarios
1. **Vercel fails, Railway succeeds**: Record both, prompt for manual recovery
2. **Railway fails, Vercel succeeds**: Rollback Vercel (keep isolated)
3. **Folio fails**: Non-blocking (observability only), deploy proceeds
4. **All fail**: Full rollback to previous version

### Risk
- âš ï¸ Increased complexity (mitigated: error handling is clear)
- âš ï¸ Race conditions (mitigated: goroutines with sync.WaitGroup)

### Decision Status: âœ… APPROVED

---

## ADR-003: Event-Driven Coordination via Printery

### Decision
Use Printery (background worker) to coordinate service dependencies after deployment stages complete, rather than embedding logic in Scribe.

### Rationale
| Aspect | Event-Driven | Embedded in Scribe |
|--------|-------------|-------------------|
| **Separation of Concerns** | âœ… Clear | âŒ Blurred |
| **Reusability** | âœ… Handlers can trigger from other events | âŒ Scribe-specific |
| **Resilience** | âœ… DLQ captures failures | âš ï¸ Process die â†’ loss |
| **Testability** | âœ… Event-driven is easier to test | âš ï¸ Orchestration logic mixed |
| **Scalability** | âœ… Multiple Printery workers | âŒ Single Scribe process |

### Event Flow
```
Scribe publishes to Redis Streams:
  {
    "type": "deployment_started",
    "version": "v1",
    "environment": "production",
    "timestamp": "2026-01-08T10:00:00Z"
  }

Printery handler receives, does pre-checks:
  â€¢ Verify all services registered
  â€¢ Check database connections
  â€¢ Validate API connectivity

  (After stages complete...)

Scribe publishes:
  {
    "type": "vercel_deployment_complete",
    "version": "v1",
    "deployment_url": "https://canvas.vercel.app"
  }

Printery handler:
  â€¢ Validates Canvas manifest
  â€¢ Pings API for integration
  â€¢ Reports health to Shield

  (All stages complete...)

Scribe publishes:
  {
    "type": "all_stages_complete",
    "version": "v1"
  }

Printery handler:
  â€¢ Runs comprehensive health check
  â€¢ Aggregates all service status
  â€¢ Reports to Shield CICD + Folio
```

### Benefits Over Alternatives
1. **Resilient**: Events stored in Redis Streams, DLQ for failures
2. **Observable**: Every event traced, logged, and timestamped
3. **Testable**: Can replay events without Scribe involvement
4. **Extensible**: Can add new handlers for future coordination needs

### Risk
- âš ï¸ Adds Redis Streams dependency (already in stack)
- âš ï¸ Event latency (mitigated: <100ms expected)

### Decision Status: âœ… APPROVED

---

## ADR-004: Unified Deployment Record in Shield CICD

### Decision
Create a new `UnifiedDeployment` model in Shield that references sub-deployments (VercelDeployment, RailwayDeployment, FolioDeployment) rather than treating them separately.

### Rationale
| Approach | Unified Record | Separate Records |
|----------|---|---|
| **Query Speed** | Single record | 3 queries (slow) |
| **UI Display** | One deployment view | 3 separate views (confusing) |
| **Rollback** | Single operation | Manual per-service |
| **Audit Trail** | One timeline | 3 timelines |
| **Atomicity** | âœ… All-or-nothing | âŒ Partial states |

### Data Model
```python
# Shield CICD models.py

class UnifiedDeployment(models.Model):
    """Master deployment record spanning Vercel + Railway + Folio"""
    deployment_id = models.UUIDField(primary_key=True)
    version = models.CharField(max_length=100)
    environment = models.CharField(max_length=20, choices=[('staging', 'Staging'), ('production', 'Production')])
    status = models.CharField(max_length=20, choices=[
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('rolled_back', 'Rolled Back'),
    ])

    # Sub-deployment references
    vercel_deployment = models.ForeignKey(
        'VercelDeployment',
        null=True,
        on_delete=models.SET_NULL,
        related_name='unified_deployment'
    )
    railway_deployment = models.ForeignKey(
        'RailwayDeployment',
        null=True,
        on_delete=models.SET_NULL,
        related_name='unified_deployment'
    )
    folio_deployment = models.ForeignKey(
        'FolioDeployment',
        null=True,
        on_delete=models.SET_NULL,
        related_name='unified_deployment'
    )

    # Timeline
    created_at = models.DateTimeField(auto_now_add=True)
    started_at = models.DateTimeField(null=True)
    completed_at = models.DateTimeField(null=True)

    # Metadata
    triggered_by = models.CharField(max_length=255)
    approval_ticket = models.CharField(max_length=255, null=True)

    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['version', 'environment']),
            models.Index(fields=['status', 'created_at']),
        ]

    @property
    def duration(self):
        if self.completed_at and self.started_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None

    @property
    def stages_status(self):
        return {
            'vercel': self.vercel_deployment.status if self.vercel_deployment else None,
            'railway': self.railway_deployment.status if self.railway_deployment else None,
            'folio': self.folio_deployment.status if self.folio_deployment else None,
        }

    def __str__(self):
        return f"Deployment {self.version} ({self.environment})"


class VercelDeployment(models.Model):
    """Vercel frontend deployment record"""
    deployment_id = models.CharField(max_length=255, unique=True)
    version = models.CharField(max_length=100)
    status = models.CharField(max_length=20, choices=[
        ('pending', 'Pending'),
        ('building', 'Building'),
        ('ready', 'Ready'),
        ('failed', 'Failed'),
    ])

    # URLs
    canvas_url = models.URLField(null=True)
    office_url = models.URLField(null=True)
    frame_url = models.URLField(null=True)

    # Timeline
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True)

    class Meta:
        ordering = ['-started_at']


class RailwayDeployment(models.Model):
    """Railway backend deployment record"""
    deployment_id = models.CharField(max_length=255, unique=True)
    version = models.CharField(max_length=100)
    status = models.CharField(max_length=20, choices=[
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('ready', 'Ready'),
        ('failed', 'Failed'),
    ])

    # Service statuses
    services = models.JSONField(default=dict)  # {api: ready, shield: ready, ...}

    # Timeline
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True)


class FolioDeployment(models.Model):
    """Folio observability deployment record"""
    deployment_id = models.CharField(max_length=255, unique=True)
    version = models.CharField(max_length=100)
    status = models.CharField(max_length=20, choices=[
        ('pending', 'Pending'),
        ('updating', 'Updating'),
        ('ready', 'Ready'),
        ('failed', 'Failed'),
    ])

    # Configuration applied
    prometheus_targets = models.IntegerField()  # Number of scrape targets configured
    grafana_dashboards = models.IntegerField()  # Number of dashboards deployed

    # Timeline
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True)
```

### WebSocket Consumer for Real-Time Updates
```python
class UnifiedDeploymentConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_group_name = f"unified_deployments"
        await self.channel_layer.group_add(self.room_group_name, self.channel_name)
        await self.accept()

    async def deployment_status_update(self, event):
        """Broadcast deployment status changes to connected clients"""
        await self.send(text_data=json.dumps({
            'type': 'deployment_update',
            'deployment_id': event['deployment_id'],
            'version': event['version'],
            'environment': event['environment'],
            'status': event['status'],
            'stages': event['stages'],
            'timestamp': event['timestamp'],
        }))
```

### Decision Status: âœ… APPROVED

---

## ADR-005: WebSocket Real-Time Progress Reporting

### Decision
Use WebSocket for real-time deployment progress updates to client dashboards rather than polling.

### Rationale
| Factor | WebSocket | HTTP Polling |
|--------|-----------|--------------|
| **Latency** | <50ms (real-time) | 1-5s (polling) |
| **Bandwidth** | Efficient (one connection) | Wasteful (repeated requests) |
| **Client UX** | Smooth updates | Jittery/delayed |
| **Server Load** | Lower (long-lived connection) | Higher (repeated requests) |
| **Browser Support** | âœ… All modern browsers | âœ… All |

### Implementation
```javascript
// Client-side (React):
const socket = new WebSocket(`ws://shield.materi.dev/ws/deployments/`);

socket.addEventListener('message', (event) => {
    const { deployment_id, status, stages } = JSON.parse(event.data);

    // Update React state in real-time
    setDeployment({
        id: deployment_id,
        status: status,
        vercelProgress: stages.vercel.progress,
        railwayProgress: stages.railway.progress,
        folioProgress: stages.folio.progress,
    });
});

// Server-side (Django Channels):
await self.channel_layer.group_send(
    'unified_deployments',
    {
        'type': 'deployment_status_update',
        'deployment_id': deployment_id,
        'status': 'in_progress',
        'stages': {
            'vercel': {'status': 'building', 'progress': 0.5},
            'railway': {'status': 'pending', 'progress': 0},
            'folio': {'status': 'pending', 'progress': 0},
        },
        'timestamp': datetime.now().isoformat(),
    }
)
```

### Risk
- âš ï¸ WebSocket connections consume memory (mitigated: reasonable connection limits)
- âš ï¸ Disconnection handling (mitigated: auto-reconnect in client)

### Decision Status: âœ… APPROVED

---

## ADR-006: Atomic Rollback Strategy

### Decision
On any stage failure, immediately rollback ALL stages to previous known-good version, rather than attempting partial recovery.

### Rationale
| Approach | Atomic Rollback | Partial Retry |
|----------|---|---|
| **Consistency** | âœ… All services match | âŒ Version mismatch |
| **Time to Recover** | Fast (4-5 min) | Slow (debugging) |
| **Operator Cognitive Load** | Low (clear state) | High (multiple states) |
| **Data Integrity** | âœ… No schema version mismatch | âŒ Potential issues |

### Implementation
```go
// Scribe rollback logic:
if err := DeployStage(vercel, version); err != nil {
    log.Printf("Vercel deployment failed: %v", err)

    // IMMEDIATE ROLLBACK
    RollbackVercel(previousVersion)
    RollbackRailway(previousVersion)
    RollbackFolio(previousVersion)

    // Report to Shield
    UpdateDeploymentStatus(deployment, "rolled_back", err.Error())

    // Exit
    return err
}
```

### Failure Handling by Stage
```
Vercel fails:
  â†’ Rollback: Vercel, Railway, Folio
  â†’ Reason: Frontend out of sync with backend

Railway fails:
  â†’ Rollback: Vercel, Railway, Folio
  â†’ Reason: Backend services not healthy

Folio fails:
  â†’ Rollback: Vercel, Railway, Folio
  â†’ Reason: Consistency (even though observability only)
```

### Decision Status: âœ… APPROVED

---

## ADR-007: Service Dependency Validation

### Decision
Before deployment, validate that all required services are present and healthy.

### Validation Checklist
```go
// Scribe pre-deployment validation:
CheckDependencies := func(version, environment string) error {
    var checks []Check

    // Infrastructure checks
    checks = append(checks, Check{
        Name: "Docker image exists",
        Fn: func() error {
            return VerifyDockerImages(version)
        },
    })

    checks = append(checks, Check{
        Name: "PostgreSQL accessible",
        Fn: func() error {
            return TestDatabaseConnection()
        },
    })

    checks = append(checks, Check{
        Name: "Redis accessible",
        Fn: func() error {
            return TestRedisConnection()
        },
    })

    // Service registry checks
    checks = append(checks, Check{
        Name: "All services registered",
        Fn: func() error {
            return ValidateServiceRegistry(version)
        },
    })

    // Folio health
    checks = append(checks, Check{
        Name: "Folio observable",
        Fn: func() error {
            return VerifyFolioConnection()
        },
    })

    // Run all checks
    for _, check := range checks {
        if err := check.Fn(); err != nil {
            return fmt.Errorf("%s failed: %v", check.Name, err)
        }
        log.Printf("âœ“ %s", check.Name)
    }

    return nil
}
```

### Decision Status: âœ… APPROVED

---

## ADR-008: Dry-Run Mode for Safety

### Decision
Provide `--dry-run` flag that shows exact deployment steps without executing them.

### Rationale
- âœ… Operators can plan deployment (predict duration, service impact)
- âœ… Verification before production
- âœ… Training/documentation (show what will happen)
- âœ… Safety (catch issues before production)

### Implementation
```bash
scribe deploy --version v1 --environment production --dry-run

# Output:
=== DEPLOYMENT PLAN: v1 â†’ production ===

Pre-deployment validation:
  âœ“ Docker images verified
  âœ“ Database connectivity OK
  âœ“ Redis connectivity OK
  âœ“ All services registered

STAGE A: Vercel Frontend
  â†’ Canvas: Deploy to vercel.com
  â†’ Office: Deploy to vercel.com
  â†’ Frame: Deploy to vercel.com
  â†’ Expected time: 3-4 minutes
  â†’ Smoke tests: Load endpoints, verify 200 OK

STAGE B: Railway Backend (Parallel)
  â†’ API: Update image to v1 tag
  â†’ Shield: Update image to v1 tag
  â†’ Relay: Update image to v1 tag
  â†’ Printery: Update image to v1 tag
  â†’ Manuscript: Update image to v1 tag
  â†’ Expected time: 5-6 minutes
  â†’ Health checks: /health endpoint on each service

STAGE C: Folio Observability
  â†’ Update Prometheus targets
  â†’ Deploy Grafana dashboards
  â†’ Configure alert rules
  â†’ Expected time: 1-2 minutes

Total deployment time: ~10 minutes

After deployment:
  â†’ Printery coordinates service dependencies
  â†’ Shield records unified deployment
  â†’ Folio ingests all metrics
  â†’ Dashboard updates in real-time

READY TO DEPLOY? Run without --dry-run to proceed.
```

### Decision Status: âœ… APPROVED

---

## ADR-009: Version Tracking & History

### Decision
Track all deployments in Shield CICD with complete history for audit and rollback purposes.

### Version History Record
```
Deployment History (Last 10):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ID  â”‚ Ver  â”‚ Env      â”‚ Status   â”‚ Duration â”‚ Timestamp        â”‚ Actor    â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ d001â”‚ v1   â”‚ prod     â”‚ âœ… ok    â”‚ 8:47     â”‚ 2026-01-08 10:00 â”‚ user@... â”‚
â”‚ d000â”‚ v0   â”‚ prod     â”‚ âœ… ok    â”‚ 9:12     â”‚ 2026-01-07 15:30 â”‚ user@... â”‚
â”‚ d-1 â”‚ v0   â”‚ staging  â”‚ âœ… ok    â”‚ 7:15     â”‚ 2026-01-07 09:00 â”‚ github   â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Click any row to see:
  â€¢ All 3 stages (Vercel, Railway, Folio)
  â€¢ Detailed timeline
  â€¢ Artifacts (logs, metrics, traces)
  â€¢ Rollback button (if desired)
```

### Decision Status: âœ… APPROVED

---

## ADR-010: Error Recovery & DLQ Replay

### Decision
Use Printery's Dead Letter Queue (DLQ) to capture any event processing failures, with on-demand replay capability.

### Benefits
1. **No Event Loss**: Even if Printery crashes, events are safely in DLQ
2. **Debugging**: Inspect exactly what failed and why
3. **Recovery**: Replay failed events after fixing root cause
4. **Audit Trail**: Complete record of retry attempts

### DLQ Flow
```
Event: deployment_started
  â†“
Printery tries to process
  â†“
Failure (e.g., API unreachable)
  â†“
Captured to DLQ table:
  {
    event_id: "evt-123",
    type: "deployment_started",
    payload: {...},
    error: "Connection refused: http://api:8080",
    retry_count: 3,
    timestamp: "2026-01-08T10:00:00Z"
  }
  â†“
Operator notification (Slack)
  â†“
Operator investigates + fixes root cause
  â†“
Operator clicks "Replay" in Shield DLQ UI
  â†“
Event re-processed successfully
```

### Decision Status: âœ… APPROVED

---

## Summary of Architecture Decisions

| ADR | Decision | Status |
|-----|----------|--------|
| **001** | Use Scribe as central orchestrator | âœ… APPROVED |
| **002** | Parallel deployment stages with explicit dependencies | âœ… APPROVED |
| **003** | Event-driven coordination via Printery | âœ… APPROVED |
| **004** | Unified deployment record in Shield CICD | âœ… APPROVED |
| **005** | WebSocket real-time progress reporting | âœ… APPROVED |
| **006** | Atomic rollback strategy on any failure | âœ… APPROVED |
| **007** | Service dependency validation pre-deployment | âœ… APPROVED |
| **008** | Dry-run mode for safety | âœ… APPROVED |
| **009** | Version tracking & history in Shield | âœ… APPROVED |
| **010** | Error recovery & DLQ replay | âœ… APPROVED |

---

## Implementation Confidence Levels

| Component | Confidence | Notes |
|-----------|-----------|-------|
| **Scribe CLI** | 95% | Framework exists (need to verify) |
| **Vercel API Integration** | 95% | Well-documented API |
| **Railway CLI Integration** | 85% | CLI works, but some uncertainty around state queries |
| **Printery Coordination** | 80% | Event system exists, coordination logic new |
| **Shield CICD Extension** | 90% | Model already exists, just adding fields |
| **WebSocket Real-time** | 95% | Django Channels proven |
| **Atomic Rollback** | 90% | Straightforward logic, version tracking needed |
| **End-to-End Integration** | 75% | Many moving parts, confidence increases with testing |

---

## Next Steps

1. âœ… Review all 10 architecture decisions
2. âœ… Approve/request changes
3. ğŸ”” Respond with **GO TASKSET 1** to begin implementation

---

**Status**: AWAITING APPROVAL
